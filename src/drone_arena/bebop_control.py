import math

from numpy import np  # noqa

import rospy
from bebop_msgs.msg import \
    Ardrone3PilotingStateFlyingStateChanged as FlyingStateChanged
from bebop_msgs.msg import \
    CommonCommonStateBatteryStateChanged as BatteryStateChanged
from geometry_msgs.msg import Twist, Vector3
from std_msgs.msg import Empty
from typing import Tuple  # noqa

from .control import BatteryState, Controller, State

F = 2.83


class BebopController(Controller):

    # ---- concrete implementation

    @staticmethod
    def cmd_from(acc, speed_z, omega):
        # type: (np.ndarray, float, float) -> Twist
        msg = Twist()
        msg.linear = Vector3(acc[0] / F, acc[1] / F, speed_z)
        msg.angular = Vector3(0, 0, omega / 1.75)
        return msg

    @staticmethod
    def from_cmd(pitch, roll, z, omega):
        # type: (float, float, float, float) -> Tuple[Tuple[float, float, float], float, float]
        return ((F * pitch, F * roll, 0), z, omega * 1.75)

    # TODO: parametrize
    def give_feedback(self):
        # type: () -> None
        t = 0.0
        A = 0.1
        n = 2
        omega = 6.0
        T = 2 * math.pi * n / omega
        dt = 0.1
        while t < T:
            z = (A * omega) * math.sin(t * omega)
            self.des_cmd_pub.publish(Twist(linear=Vector3(0, 0, z)))
            t += dt
            rospy.sleep(dt)
        self.des_cmd_pub.publish(Twist(linear=Vector3(0, 0, 0)))

    def stop(self, msg=None):
        # type: (Empty) -> None
        self.pub_reset.publish()

    def hover(self):
        # type: () -> None
        if self.state == State.flying:
            self.des_cmd_pub.publish(Twist())

    def takeoff(self):
        # type: () -> None
        self.pub_takeoff.publish(Empty())
        # TODO: add callback (currently not working in bebop driver + melodic)

    def land(self):
        # type: () -> None
        self.pub_land.publish(Empty())

    def __init__(self):
        # type: () -> None
        super(BebopController, self).__init__()
        rospy.set_param('bebop_driver/states/enable_pilotingstate_flyingstatechanged', True)
        rospy.Subscriber('states/ardrone3/PilotingState/FlyingStateChanged', FlyingStateChanged,
                         self.state_has_changed)
        rospy.set_param('bebop_driver/states/enable_commonstate_batterystatechanged', True)
        rospy.Subscriber('states/common/CommonState/BatteryStateChanged', BatteryStateChanged,
                         self.has_received_battery)
        self.battery_state = BatteryState.ok
        self.pub_takeoff = rospy.Publisher('takeoff', Empty, queue_size=1)
        self.pub_land = rospy.Publisher('land', Empty, queue_size=1)
        self.pub_reset = rospy.Publisher('reset', Empty, queue_size=1)

    def has_received_battery(self, msg):
        # type: (BatteryStateChanged) -> None
        if msg.percent < 5 and self.battery_state == BatteryState.ok:
            self.battery_state = BatteryState.critical
        if msg.percent < 2 and self.battery_state == BatteryState.critical:
            self.battery_state = BatteryState.empty
        self.battery_percent = msg.percent

    def state_has_changed(self, msg):
        # type: (FlyingStateChanged) -> None
        # Ardrone3PilotingStateFlyingStateChanged.msg
        # see https://bebop-autonomy.readthedocs.io/en/latest/autogenerated/
        # ardrone3_states_param_topic.html
        # uint8 state_landed=0  # Landed state
        # uint8 state_takingoff=1  # Taking off state
        # uint8 state_hovering=2  # Hovering / Circling (for fixed wings) state
        # uint8 state_flying=3  # Flying state
        # uint8 state_landing=4  # Landing state
        # uint8 state_emergency=5  # Emergency state
        # uint8 state_usertakeoff=6  # User take off state. Waiting for user action to take off.
        # uint8 state_motor_ramping=7  # Motor ramping state (for fixed wings).
        # uint8 state_emergency_landing=8  # Emergency landing state. Drone autopilot
        # has detected defective sensor(s). Only Yaw argument in PCMD is taken into account.
        # All others flying commands are ignored.
        # uint8 state
        # rospy.loginfo("state_has_changed %s", msg)
        if msg.state == FlyingStateChanged.state_takingoff:
            self.state = State.taking_off
        elif msg.state == FlyingStateChanged.state_hovering:
            self.state = State.hovering
        elif msg.state == FlyingStateChanged.state_flying:
            self.state = State.flying
        elif msg.state in [FlyingStateChanged.state_landing,
                           FlyingStateChanged.state_emergency_landing]:
            self.state = State.landing
        elif msg.state in [FlyingStateChanged.state_landed, FlyingStateChanged.state_emergency]:
            self.state = State.landed
        else:
            rospy.logwarn("Unexpected state msg %s for bebop", msg)
        # rospy.loginfo("bebop state -> %s", self.state)
