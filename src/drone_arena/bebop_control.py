import rospy
from bebop_msgs.msg import CommonCommonStateBatteryStateChanged as BatteryStateChanged
from bebop_msgs.msg import Ardrone3PilotingStateFlyingStateChanged as FlyingStateChanged
from geometry_msgs.msg import Twist, Vector3
from std_msgs.msg import Empty
from .control import BatteryState, Controller, State
import math

F = 2.83


class BebopController(Controller):

    @staticmethod
    def cmd_from_acc(acc, speed_z):
        return [acc[0] / F, acc[1] / F, speed_z]

    @staticmethod
    def vert_vel_from_cmd(value):
        return value

    @staticmethod
    def acc_from_cmd(cmd_vel):
        return [F * cmd_vel[0], F * cmd_vel[1], 0]

    @staticmethod
    def cmd_from_angular_speed(omega):
        return omega / 1.75

    @staticmethod
    def angular_speed_from_cmd(cmd):
        return cmd * 1.75

    @staticmethod
    def cmd_from_angular_speed(value):
        return value / 1.75

    def give_feedback(self):
        t = 0.0
        A = 0.1
        n = 2
        omega = 6.0
        T = 2 * math.pi * n / omega
        dt = 0.1
        while t < T:
            z = (A * omega) * math.sin(t * omega)
            self.des_cmd_pub.publish(Twist(linear=Vector3(0, 0, z)))
            t += dt
            rospy.sleep(dt)
        self.des_cmd_pub.publish(Twist(linear=Vector3(0, 0, 0)))

    def hover(self):
        if self.state == State.flying:
            self.des_cmd_pub.publish(Twist())

    def __init__(self):
        super(BebopController, self).__init__()
        rospy.set_param('bebop_driver/states/enable_pilotingstate_flyingstatechanged', True)
        rospy.Subscriber('states/ardrone3/PilotingState/FlyingStateChanged', FlyingStateChanged,
                         self.state_has_changed)
        rospy.set_param('bebop_driver/states/enable_commonstate_batterystatechanged', True)
        rospy.Subscriber('states/common/CommonState/BatteryStateChanged', BatteryStateChanged,
                         self.has_received_battery)

        self.pub_takeoff = rospy.Publisher('takeoff', Empty, queue_size=1)
        self.pub_land = rospy.Publisher('land', Empty, queue_size=1)

    def takeoff(self):
        self.pub_takeoff.publish(Empty())
        # TODO: add callback (currntly not working in bebop driver + melodic)

    def land(self):
        self.pub_land.publish(Empty())

    def has_received_battery(self, msg):
        if msg.percent < 5 and self.battery_state == BatteryState.ok:
            self.battery_state = BatteryState.critical
        if msg.percent < 2 and self.battery_state == BatteryState.critical:
            self.battery_state = BatteryState.empty

    def state_has_changed(self, msg):
        # Ardrone3PilotingStateFlyingStateChanged.msg
        # see https://bebop-autonomy.readthedocs.io/en/latest/autogenerated/
        # ardrone3_states_param_topic.html
        # uint8 state_landed=0  # Landed state
        # uint8 state_takingoff=1  # Taking off state
        # uint8 state_hovering=2  # Hovering / Circling (for fixed wings) state
        # uint8 state_flying=3  # Flying state
        # uint8 state_landing=4  # Landing state
        # uint8 state_emergency=5  # Emergency state
        # uint8 state_usertakeoff=6  # User take off state. Waiting for user action to take off.
        # uint8 state_motor_ramping=7  # Motor ramping state (for fixed wings).
        # uint8 state_emergency_landing=8  # Emergency landing state. Drone autopilot
        # has detected defective sensor(s). Only Yaw argument in PCMD is taken into account.
        # All others flying commands are ignored.
        # uint8 state
        # rospy.loginfo("state_has_changed %s", msg)
        if msg.state == FlyingStateChanged.state_takingoff:
            self.state = State.taking_off
        elif msg.state == FlyingStateChanged.state_hovering:
            self.state = State.hovering
        elif msg.state == FlyingStateChanged.state_flying:
            self.state = State.flying
        elif msg.state in [FlyingStateChanged.state_landing,
                           FlyingStateChanged.state_emergency_landing]:
            self.state = State.landing
        elif msg.state in [FlyingStateChanged.state_landed]:
            self.state = State.landed
        else:
            rospy.logwarn("Unexpected state msg %s for bebop", msg)
        # rospy.loginfo("bebop state -> %s", self.state)
